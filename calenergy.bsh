# a script for calculate free energy landscape
# Comparison of protein
echo -e "Protein\nProtein\n" | gmx trjconv -f traj_10_30ns.trr -s  md.tpr -fit rot+trans -o mdfit.trr
# Generate covariance matrix and calculate eigenvector and eigenvalue
echo -e "C-alpha\nC-alpha\n" | gmx covar -s md.gro -f mdfit.trr -o eigenvalues.xvg -v eigenvectors.trr -xpma covapic.xpm
# The trajectory is projected onto the selected eigenvector
echo -e "C-alpha\nC-alpha\n" | gmx anaeig -f mdfit.trr -s md.gro -v eigenvectors.trr -last 1 -proj pc1.xvg
echo -e "C-alpha\nC-alpha\n" | gmx anaeig -f mdfit.trr -s md.gro -v eigenvectors.trr -first 2 -last 2 -proj pc2.xvg

cat > sham.pl <<- "EOF"
#!/usr/bin/perl -w

# This program reads in two .xvg files (specified on the command line) and prints out a
# concatenated output file suitable for input into g_sham for generating free energy landscapes.
# The output line contains, for example: time value1 value2
#
# Caveat 1 (should be obvious): both input files must contain the same number of data points
# Caveat 2: the desired quantity should be the second item on the line in the .xvg file (after time)
#
# Values of -data1 and -data2 are the number of the data set in the input .xvg file(s), i.e. 0 would
# be the first column (usually time), 1 would be the first data set, etc.

use strict;

unless (@ARGV) {
    die "Usage: perl sham.pl -i1 input1.xvg -i2 input2.xvg -data1 1 -data2 1 -o graph.xvg\n";
}

my %args = @ARGV;

# define input and output files
my $input1;
my $input2;
my $output;

if (exists($args{"-i1"})) {
    $input1 = $args{"-i1"};
} else {
    die "No -i1 specified!\n";
}

if (exists($args{"-i2"})) {
    $input2 = $args{"-i2"};
} else {
    die "No -i2 specified!\n";
}

if (exists($args{"-o"})) {
    $output = $args{"-o"};
} else {
    $output = "graph.xvg";  # default output name
}

# define input data sets
my $d1;
my $d2;

if (exists($args{"-data1"})) {
    $d1 = $args{"-data1"};
} else {
    $d1 = 1;    # default to first non-time data column
}

if (exists($args{"-data2"})) {
    $d2 = $args{"-data2"};
} else {
    $d2 = 1;
}

open(IN1, "<$input1") || die "$!: Cannot open $input1";
my @in1 = <IN1>;
close(IN1);

open(IN2, "<$input2") || die "$!: Cannot open $input2";
my @in2 = <IN2>;
close(IN2);

# need to chop off the headers first, since they may cause files with the same number of data
# points to have different lengths (one file has more header info than another

my $size1 = scalar(@in1);

for (my $i=0; $i<$size1; $i++) {
    if ($in1[$i] =~ /^[#@]/) {
        splice(@in1, $i, 1);
        $i--;
        $size1--;
    }
}

my $size2 = scalar(@in2);

for (my $j=0; $j<$size2; $j++) {
    if ($in2[$j] =~ /^[#@]/) {
        splice(@in2, $j, 1);
        $j--;
        $size2--;
    }
}

# debug
# print "@in1\n";
# print "@in2\n";

open(OUT, ">>$output") || die "$!: Cannot open $output\n";
print OUT "# graph.xvg for g_sham\n";

for (my $i=0; $i<scalar(@in1); $i++) {
    my $line1 = $in1[$i];
    my $line2 = $in2[$i];

    if (($line1 =~ /^[#@]/) || ($line2 =~ /^[#@]/)) {
        # do nothing, it's a comment - probably not necessary after above cleanup
    } else {
        my @data1 = split(" ", $line1);
        my @data2 = split(" ", $line2);

        my $time = $data1[0];
        my $val1 = $data1[$d1];
        my $val2 = $data2[$d2];

        printf OUT "%8.3f\t%f\t%f\n", $time, $val1, $val2;
    }
}

close(OUT);

exit;
EOF

# Merge columns
perl sham.pl -i1 pc1.xvg -i2 pc2.xvg -data 1 -data2 1 -o gsham_input.xvg
# Generate free energy landscape
gmx sham -f gsham_input.xvg -ls FEL.xpm

cat > xpm2txt.py <<- "EOS"
#!/usr/bin/env python

import sys

"""
Utility tool to convert xpm files generated by GROMACS to a 3-column text file.
"""

USAGE = "USAGE: xpm2txt.py -f <input xpm file> -o <output txt file> [-s]\n"
USAGE+= "Options:\n"
USAGE+= "\t-s\t(int)\tSorts the output by a given column"
USAGE+= "\n" # always keep this line

# Parse arguments
read_input, read_output, sort = False, False, False
xpm_file, out_file, column_sort = None, None, None
for arg in sys.argv[1:]:
    if read_input:
        read_input = False
        xpm_file = arg
    elif read_output:
        read_output = False
        out_file = arg
    elif sort:
        sort = False
        column_sort = int(arg)
    if arg[0] == "-":
        if arg == "-f":
            read_input = True
            continue
        elif arg == "-o":
            read_output = True
            continue
        elif arg == "-s":
            sort = True
        else:
            print USAGE
            sys.stderr.write('ERROR: Option not recognized: %s\n' %arg)
            sys.exit(1)

if not xpm_file:
    print USAGE
    sys.stderr.write('ERROR: You forgot to provide an input file.\n')
    sys.exit(1)
if not out_file:
    out_file = "out.txt"

# Parse XPM file
xpm_handle = open(xpm_file)
xpm_data = []
x_axis, y_axis = [], []
letter_to_value = {}
for line in xpm_handle:
    if line.startswith("/* x-axis"):
        x_axis = map(float, line.split()[2:-2]) # We trim the last value

    if line.startswith("/* y-axis"):
        y_axis = map(float, line.split()[2:-2]) # We trim the last value

    if line.startswith('"') and x_axis and y_axis: # Read data
        xpm_data.insert(0, line.strip().strip(',')[1:-1])

    if line.startswith('"') and len(line.split()) > 4:
        letter = line.split()[0][1:]
        value = float(line.split()[-2][1:-1])
        letter_to_value[letter] = value
xpm_handle.close()

# Match x/y/data
txt_values = []
for y_index, data_value in enumerate(xpm_data):
    y_value = y_axis[y_index]
    for x_index, x_value in enumerate(x_axis):
        txt_values.append([x_value, y_value, letter_to_value[data_value[x_index]]])

# Apply sorting if requested
if column_sort:
    try:
        txt_values.sort(key=lambda x: x[column_sort-1])
    except IndexError:
        print USAGE
        sys.stderr.write('ERROR: Column not found (%s)\n' %(column_sort))
        sys.exit(1)

# Print to file
out_handle = open(out_file, 'w')
for x, y, z in txt_values:
    out_handle.write("%3.5f\t%3.5f\t%3.5f\n" %(x,y,z))
out_handle.close()
    
EOS

# Trans FEL.xpm to txt file (python2.7)
python xpm2txt.py -f FEL.xpm -o free-energy-landscape.txt
# Creat a matlab code for draw free energy landscape figure
cat > free-energy-map.m <<- "EOD"
clear;
clc;
%读取数据
[x,y,z] = textread('free-energy-landscape.txt','%f%f%f');
%拟合曲面
[X,Y,Z] = griddata(x,y,z,linspace(min(x),max(x))',linspace(min(y),max(y)),'v4');
%绘图
figure
surf(X,Y,Z)
%插值
shading interp
%颜色
colormap ('jet')
colorbar 
%坐标轴
xlabel ('PC1');
ylabel ('PC2');
zlabel ('Energy (kJ/mol)');

EOD
echo Calculation Finished!
